import {
  require_vue
} from "./chunk-WWNBI5GT.js";
import "./chunk-2X3TLQUF.js";
import {
  __commonJS
} from "./chunk-AUZ3RYOM.js";

// node_modules/@tinymce/tinymce-vue/lib/cjs/main/ts/Utils.js
var require_Utils = __commonJS({
  "node_modules/@tinymce/tinymce-vue/lib/cjs/main/ts/Utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isNullOrUndefined = exports.mergePlugins = exports.isTextarea = exports.uuid = exports.isValidKey = exports.initEditor = exports.bindModelHandlers = exports.bindHandlers = void 0;
    var vue_1 = require_vue();
    var validEvents = [
      "onActivate",
      "onAddUndo",
      "onBeforeAddUndo",
      "onBeforeExecCommand",
      "onBeforeGetContent",
      "onBeforeRenderUI",
      "onBeforeSetContent",
      "onBeforePaste",
      "onBlur",
      "onChange",
      "onClearUndos",
      "onClick",
      "onContextMenu",
      "onCopy",
      "onCut",
      "onDblclick",
      "onDeactivate",
      "onDirty",
      "onDrag",
      "onDragDrop",
      "onDragEnd",
      "onDragGesture",
      "onDragOver",
      "onDrop",
      "onExecCommand",
      "onFocus",
      "onFocusIn",
      "onFocusOut",
      "onGetContent",
      "onHide",
      "onInit",
      "onKeyDown",
      "onKeyPress",
      "onKeyUp",
      "onLoadContent",
      "onMouseDown",
      "onMouseEnter",
      "onMouseLeave",
      "onMouseMove",
      "onMouseOut",
      "onMouseOver",
      "onMouseUp",
      "onNodeChange",
      "onObjectResizeStart",
      "onObjectResized",
      "onObjectSelected",
      "onPaste",
      "onPostProcess",
      "onPostRender",
      "onPreProcess",
      "onProgressState",
      "onRedo",
      "onRemove",
      "onReset",
      "onSaveContent",
      "onSelectionChange",
      "onSetAttrib",
      "onSetContent",
      "onShow",
      "onSubmit",
      "onUndo",
      "onVisualAid"
    ];
    var isValidKey = function(key) {
      return validEvents.map(function(event) {
        return event.toLowerCase();
      }).indexOf(key.toLowerCase()) !== -1;
    };
    exports.isValidKey = isValidKey;
    var bindHandlers = function(initEvent, listeners, editor) {
      Object.keys(listeners).filter(isValidKey).forEach(function(key) {
        var handler = listeners[key];
        if (typeof handler === "function") {
          if (key === "onInit") {
            handler(initEvent, editor);
          } else {
            editor.on(key.substring(2), function(e) {
              return handler(e, editor);
            });
          }
        }
      });
    };
    exports.bindHandlers = bindHandlers;
    var bindModelHandlers = function(props, ctx, editor, modelValue) {
      var modelEvents = props.modelEvents ? props.modelEvents : null;
      var normalizedEvents = Array.isArray(modelEvents) ? modelEvents.join(" ") : modelEvents;
      vue_1.watch(modelValue, function(val, prevVal) {
        if (editor && typeof val === "string" && val !== prevVal && val !== editor.getContent({ format: props.outputFormat })) {
          editor.setContent(val);
        }
      });
      editor.on(normalizedEvents ? normalizedEvents : "change input undo redo", function() {
        ctx.emit("update:modelValue", editor.getContent({ format: props.outputFormat }));
      });
    };
    exports.bindModelHandlers = bindModelHandlers;
    var initEditor = function(initEvent, props, ctx, editor, modelValue, content) {
      editor.setContent(content());
      if (ctx.attrs["onUpdate:modelValue"]) {
        bindModelHandlers(props, ctx, editor, modelValue);
      }
      bindHandlers(initEvent, ctx.attrs, editor);
    };
    exports.initEditor = initEditor;
    var unique = 0;
    var uuid = function(prefix) {
      var time = Date.now();
      var random = Math.floor(Math.random() * 1e9);
      unique++;
      return prefix + "_" + random + unique + String(time);
    };
    exports.uuid = uuid;
    var isTextarea = function(element) {
      return element !== null && element.tagName.toLowerCase() === "textarea";
    };
    exports.isTextarea = isTextarea;
    var normalizePluginArray = function(plugins) {
      if (typeof plugins === "undefined" || plugins === "") {
        return [];
      }
      return Array.isArray(plugins) ? plugins : plugins.split(" ");
    };
    var mergePlugins = function(initPlugins, inputPlugins) {
      return normalizePluginArray(initPlugins).concat(normalizePluginArray(inputPlugins));
    };
    exports.mergePlugins = mergePlugins;
    var isNullOrUndefined = function(value) {
      return value === null || value === void 0;
    };
    exports.isNullOrUndefined = isNullOrUndefined;
  }
});

// node_modules/@tinymce/tinymce-vue/lib/cjs/main/ts/ScriptLoader.js
var require_ScriptLoader = __commonJS({
  "node_modules/@tinymce/tinymce-vue/lib/cjs/main/ts/ScriptLoader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ScriptLoader = void 0;
    var Utils_1 = require_Utils();
    var createState = function() {
      return {
        listeners: [],
        scriptId: Utils_1.uuid("tiny-script"),
        scriptLoaded: false
      };
    };
    var CreateScriptLoader = function() {
      var state = createState();
      var injectScriptTag = function(scriptId, doc, url, callback) {
        var scriptTag = doc.createElement("script");
        scriptTag.referrerPolicy = "origin";
        scriptTag.type = "application/javascript";
        scriptTag.id = scriptId;
        scriptTag.src = url;
        var handler = function() {
          scriptTag.removeEventListener("load", handler);
          callback();
        };
        scriptTag.addEventListener("load", handler);
        if (doc.head) {
          doc.head.appendChild(scriptTag);
        }
      };
      var load = function(doc, url, callback) {
        if (state.scriptLoaded) {
          callback();
        } else {
          state.listeners.push(callback);
          if (!doc.getElementById(state.scriptId)) {
            injectScriptTag(state.scriptId, doc, url, function() {
              state.listeners.forEach(function(fn) {
                return fn();
              });
              state.scriptLoaded = true;
            });
          }
        }
      };
      var reinitialize = function() {
        state = createState();
      };
      return {
        load,
        reinitialize
      };
    };
    var ScriptLoader = CreateScriptLoader();
    exports.ScriptLoader = ScriptLoader;
  }
});

// node_modules/@tinymce/tinymce-vue/lib/cjs/main/ts/TinyMCE.js
var require_TinyMCE = __commonJS({
  "node_modules/@tinymce/tinymce-vue/lib/cjs/main/ts/TinyMCE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTinymce = void 0;
    var getGlobal = function() {
      return typeof window !== "undefined" ? window : global;
    };
    var getTinymce = function() {
      var global2 = getGlobal();
      return global2 && global2.tinymce ? global2.tinymce : null;
    };
    exports.getTinymce = getTinymce;
  }
});

// node_modules/@tinymce/tinymce-vue/lib/cjs/main/ts/components/EditorPropTypes.js
var require_EditorPropTypes = __commonJS({
  "node_modules/@tinymce/tinymce-vue/lib/cjs/main/ts/components/EditorPropTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.editorProps = void 0;
    exports.editorProps = {
      apiKey: String,
      cloudChannel: String,
      id: String,
      init: Object,
      initialValue: String,
      inline: Boolean,
      modelEvents: [String, Array],
      plugins: [String, Array],
      tagName: String,
      toolbar: [String, Array],
      modelValue: String,
      disabled: Boolean,
      tinymceScriptSrc: String,
      outputFormat: {
        type: String,
        validator: function(prop) {
          return prop === "html" || prop === "text";
        }
      }
    };
  }
});

// node_modules/@tinymce/tinymce-vue/lib/cjs/main/ts/components/Editor.js
var require_Editor = __commonJS({
  "node_modules/@tinymce/tinymce-vue/lib/cjs/main/ts/components/Editor.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Editor = void 0;
    var ScriptLoader_1 = require_ScriptLoader();
    var TinyMCE_1 = require_TinyMCE();
    var Utils_1 = require_Utils();
    var EditorPropTypes_1 = require_EditorPropTypes();
    var vue_1 = require_vue();
    var renderInline = function(ce, id, elementRef, tagName) {
      return ce(tagName ? tagName : "div", {
        id,
        ref: elementRef
      });
    };
    var renderIframe = function(ce, id, elementRef) {
      return ce("textarea", {
        id,
        visibility: "hidden",
        ref: elementRef
      });
    };
    exports.Editor = vue_1.defineComponent({
      props: EditorPropTypes_1.editorProps,
      setup: function(props, ctx) {
        var _a = vue_1.toRefs(props), disabled = _a.disabled, modelValue = _a.modelValue;
        var element = vue_1.ref(null);
        var vueEditor = null;
        var elementId = props.id || Utils_1.uuid("tiny-vue");
        var inlineEditor = props.init && props.init.inline || props.inline;
        var modelBind = !!ctx.attrs["onUpdate:modelValue"];
        var mounting = true;
        var initialValue = props.initialValue ? props.initialValue : "";
        var cache = "";
        var getContent = function(isMounting) {
          return modelBind ? function() {
            return (modelValue === null || modelValue === void 0 ? void 0 : modelValue.value) ? modelValue.value : "";
          } : function() {
            return isMounting ? initialValue : cache;
          };
        };
        var initWrapper = function() {
          var content = getContent(mounting);
          var finalInit = __assign(__assign({}, props.init), { readonly: props.disabled, selector: "#" + elementId, plugins: Utils_1.mergePlugins(props.init && props.init.plugins, props.plugins), toolbar: props.toolbar || props.init && props.init.toolbar, inline: inlineEditor, setup: function(editor) {
            vueEditor = editor;
            editor.on("init", function(e) {
              return Utils_1.initEditor(e, props, ctx, editor, modelValue, content);
            });
            if (props.init && typeof props.init.setup === "function") {
              props.init.setup(editor);
            }
          } });
          if (Utils_1.isTextarea(element.value)) {
            element.value.style.visibility = "";
          }
          TinyMCE_1.getTinymce().init(finalInit);
          mounting = false;
        };
        vue_1.watch(disabled, function(disable) {
          if (vueEditor !== null) {
            vueEditor.setMode(disable ? "readonly" : "design");
          }
        });
        vue_1.onMounted(function() {
          if (TinyMCE_1.getTinymce() !== null) {
            initWrapper();
          } else if (element.value && element.value.ownerDocument) {
            var channel = props.cloudChannel ? props.cloudChannel : "5";
            var apiKey = props.apiKey ? props.apiKey : "no-api-key";
            var scriptSrc = Utils_1.isNullOrUndefined(props.tinymceScriptSrc) ? "https://cdn.tiny.cloud/1/" + apiKey + "/tinymce/" + channel + "/tinymce.min.js" : props.tinymceScriptSrc;
            ScriptLoader_1.ScriptLoader.load(element.value.ownerDocument, scriptSrc, initWrapper);
          }
        });
        vue_1.onBeforeUnmount(function() {
          if (TinyMCE_1.getTinymce() !== null) {
            TinyMCE_1.getTinymce().remove(vueEditor);
          }
        });
        if (!inlineEditor) {
          vue_1.onActivated(function() {
            if (!mounting) {
              initWrapper();
            }
          });
          vue_1.onDeactivated(function() {
            var _a2;
            if (!modelBind) {
              cache = vueEditor.getContent();
            }
            (_a2 = TinyMCE_1.getTinymce()) === null || _a2 === void 0 ? void 0 : _a2.remove(vueEditor);
          });
        }
        return function() {
          return inlineEditor ? renderInline(vue_1.h, elementId, element, props.tagName) : renderIframe(vue_1.h, elementId, element);
        };
      }
    });
  }
});

// node_modules/@tinymce/tinymce-vue/lib/cjs/main/ts/index.js
var require_ts = __commonJS({
  "node_modules/@tinymce/tinymce-vue/lib/cjs/main/ts/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var Editor_1 = require_Editor();
    exports.default = Editor_1.Editor;
  }
});
export default require_ts();
//# sourceMappingURL=@tinymce_tinymce-vue_lib_cjs_main_ts_index.js.map
